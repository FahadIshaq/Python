from collections import defaultdict

def calculate_first_sets(production_rules):
    first_sets = defaultdict(set)
    visited = set()  # To track visited non-terminals
    
    def calc_first(symbol):
        if symbol not in first_sets:
            if symbol in visited:
                return set()  # Or raise an error to signify cycle
            visited.add(symbol)
            
            if symbol not in production_rules:
                first_sets[symbol].add(symbol)
                return first_sets[symbol]
            
            for production in production_rules[symbol]:
                if production == ['null']:  # Corrected this line to compare with a list
                    first_sets[symbol].add('null')
                    continue
                
                for s in production:
                    first_s = calc_first(s)
                    first_sets[symbol].update(first_s - {'null'})
                    
                    if 'null' not in first_s:
                        break
                else:
                    first_sets[symbol].add('null')
                    
        return first_sets[symbol]
    
    for non_terminal in production_rules:
        calc_first(non_terminal)
        
    return first_sets

def calculate_follow_sets(production_rules, first_sets):
    follow_sets = defaultdict(set)
    
    def calc_follow(symbol):
        if symbol not in follow_sets:
            if symbol not in production_rules:
                return set()
            
            for nt, productions in production_rules.items():
                for production in productions:
                    if symbol in production:
                        index = production.index(symbol)
                        follow = set()
                        
                        for i in range(index + 1, len(production)):
                            if 'null' in first_sets[production[i]]:
                                follow.update(first_sets[production[i]] - {'null'})
                            else:
                                follow.update(first_sets[production[i]])
                                break
                        else:
                            follow.update(calc_follow(nt))
                        
                        follow_sets[symbol].update(follow)
                    
        return follow_sets[symbol]
    
    start_symbol = list(production_rules.keys())[0]
    follow_sets[start_symbol].add('$')
    
    for non_terminal in production_rules:
        calc_follow(non_terminal)
    
    return follow_sets


def construct_parsing_table(production_rules, first_sets, follow_sets):
    parsing_table = defaultdict(dict)
    
    for nt, productions in production_rules.items():
        for production in productions:
            first_set = set()
            for symbol in production:
                first_set.update(first_sets[symbol])
                if 'null' not in first_sets[symbol]:
                    break
            else:
                first_set.add('null')
                
            for terminal in first_set - {'null'}:
                parsing_table[nt][terminal] = f"{nt} -> {' '.join(production)}"
            
            if 'null' in first_set:
                for terminal in follow_sets[nt]:
                    parsing_table[nt][terminal] = f"{nt} -> {' '.join(production)}"
    
    return parsing_table

def ll1_parsing(input_tape, parsing_table, start_symbol):
    stack = [start_symbol]
    cursor = 0
    
    while stack:
        top = stack.pop()
        
        if top in parsing_table:
            if input_tape[cursor] in parsing_table[top]:
                production = parsing_table[top][input_tape[cursor]].split('->')[1].strip().split()
                stack.extend(reversed(production))
            else:
                return "Input string cannot be generated by the grammar."
        
        elif top == input_tape[cursor]:
            cursor += 1
        elif top == 'null':
            continue
        else:
            return "Input string cannot be generated by the grammar."
    
    return "Input string can be generated by the grammar."

def main():
    num_terminals = int(input("Enter the number of terminals: "))
    terminals = input(f"Enter the {num_terminals} terminals separated by space: ").split()
    
    num_non_terminals = int(input("Enter the number of non-terminals: "))
    non_terminals = input(f"Enter the {num_non_terminals} non-terminals separated by space: ").split()
    
    num_rules = int(input("Enter the number of production rules: "))
    production_rules = defaultdict(list)
    
    for _ in range(num_rules):
        lhs, rhs = input("Enter a production rule (lhs -> rhs): ").split("->")
        production_rules[lhs.strip()].append(rhs.strip().split())
    
    first_sets = calculate_first_sets(production_rules)
    follow_sets = calculate_follow_sets(production_rules, first_sets)
    
    print("FIRST Sets:")
    for nt, first_set in first_sets.items():
        print(f"FIRST({nt}) = {first_set}")
    
    print("\nFOLLOW Sets:")
    for nt, follow_set in follow_sets.items():
        print(f"FOLLOW({nt}) = {follow_set}")
    parsing_table = construct_parsing_table(production_rules, first_sets, follow_sets)
    
    print("\nParsing Table:")
    for nt, entries in parsing_table.items():
        print(f"{nt}: {entries}")
        
    input_tape = input("Enter the input tape (input string): ")
    result = ll1_parsing(input_tape, parsing_table, list(production_rules.keys())[0])
    
    print(result)

if __name__ == '__main__':
    main()
